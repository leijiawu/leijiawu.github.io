<!doctype html>
<html lang="zn-CN">

	<head>
		<meta charset="utf-8">
		<title>CG课内实验</title>
		<link rel="stylesheet" type="text/css" href="page2.css">
	</head>
	<body>
		<div class="nav1">
			<div class="nav2">
				<ul class="ul1">
  				<li><a href="index.html">主页</a></li>
  				<li><a href="page2.html">CG课内实验</a></li>
  				<li><a href="page3.html">CG拓展题</a></li>
				<li><a href="page4.html">学习资料</a></li>
				<li><a href="page5.html">实用网站</a></li>
			  </ul>
			</div>
		</div>
		<div class="main1">
			<div class="left1">
				<details class="details1">
					<summary>数据结构-图-课内</summary>
					<ul>
						<li><a href="#tu_1">1、创建图</a></li>
						<li><a href="#tu_2">2、求图的顶点</a></li>
					</ul>
				</details>
			</div>
			<div class="main2">
				<div class="contains" id="tu_1">
					<p>1、创建图</p>
					<pre>
#include&lt;iostream&gt;
#include&lt;stdio.h&gt;
using namespace std;
#define	infinity	10000
#define	max_vertex_num	20
#define error 0
#define ok 1

typedef int status;
typedef	int	vrtype;
typedef	int	infotype;
typedef	char vertextype;//鼎点的数据类型现在是cahr 
typedef	int	graphkind;	//（1-有向图，2-有向网，3-无向图，4-无向网）

//enum graphkind{DG,DN,AG,AN}; 

typedef	struct	arccell{
	vrtype 		adj;
	infotype* 	info;
}arccell,adjmatrix[max_vertex_num][max_vertex_num];

typedef struct{
	vertextype	vexs[max_vertex_num];
	adjmatrix	arcs;
	int			vexnum, arcnum;
	graphkind	kind;
}mgraph;

int locatevex(mgraph g,vertextype v){
	int i=0;
	for(;i&lt;=g.vexnum-1;i++){
		if(g.vexs[i]==v){
			return i;
		}
	}
	return -1;
} 

status createdn(mgraph &amp;g){
	int i,j,k;
	vrtype w;
	int kd;
	vertextype v1,v2;
	//cout&lt;&lt;"请输入2和有向网G的顶点数，弧数:"; 
	cin&gt;&gt;kd&gt;&gt;g.vexnum&gt;&gt;g.arcnum;
	//cout&lt;&lt;"请输入"&lt;&lt;g.vexnum&lt;&lt;"个顶点的值";
	for(i=0;i&lt;g.vexnum;i++){
		cin&gt;&gt;g.vexs[i];
	} 
	
	for(i=0;i&lt;g.vexnum;i++){
		for(j=0;j&lt;g.vexnum;j++){
			g.arcs[i][j].adj=infinity;
		}
	}
	//cout&lt;&lt;"请输入"&lt;&lt;g.arcnum&lt;&lt;"条弧的弧尾 弧头 权值：" &lt;&lt;endl;
	for(k=0;k&lt;g.arcnum;k++){
		cin&gt;&gt;v1&gt;&gt;v2&gt;&gt;w;
		i=locatevex(g,v1);
		j=locatevex(g,v2);
		g.arcs[i][j].adj=w;
	} 
	g.kind=kd;
	return ok;
}

status printdn(mgraph g){
	int i,j;
	printf("%d %d %d\n",g.kind,g.vexnum, g.arcnum);
	for(i=0;i&lt;g.vexnum;i++){
		printf("%c",g.vexs[i]);
	}
	printf("\n");
	for(i=0;i&lt;g.vexnum;i++){ 
		for(j=0;j&lt;g.vexnum;++j){//老师的j是j=i 
		if(g.arcs[i][j].adj&lt;infinity){
			printf("%d",g.arcs[i][j].adj);
		}
		else{
			printf("#");
		}
		}
		printf("\n");
	}
	return ok;
}


int  main(){
	mgraph g;
	//printf("1-有向图，2-有向网，3-无向图，4-无向网\n");
	createdn(g);
	printdn(g);
	return 0;
} 					
					</pre>
				</div>
				<div class="contains" id="tu_2">
					<p>2、求顶点的度</p>
					<pre>
#include&lt;iostream&gt;
#include&lt;stdio.h&gt;
using namespace std;
#define	infinity	10000
#define	max_vertex_num	20
#define error 0
#define ok 1

typedef int status;
typedef	int	vrtype;
typedef	int	infotype;
typedef	char vertextype;//鼎点的数据类型现在是cahr 
typedef	int	graphkind;	//（1-有向图，2-有向网，3-无向图，4-无向网）

//enum graphkind{DG,DN,AG,AN}; 

typedef	struct	arccell{
	vrtype 		adj;
	infotype* 	info;
}arccell,adjmatrix[max_vertex_num][max_vertex_num];

typedef struct{
	vertextype	vexs[max_vertex_num];
	adjmatrix	arcs;
	int			vexnum, arcnum;
	graphkind	kind;
}mgraph;

int locatevex(mgraph g,vertextype v){
	int i=0;
	for(;i&lt;=g.vexnum-1;i++){
		if(g.vexs[i]==v){
			return i;
		}
	}
	return -1;
} 

status createdn(mgraph &amp;g){
	int i,j,k;
	vrtype w;
	int kd;
	vertextype v1,v2;
	//cout&lt;&lt;"请输入2和有向网G的顶点数，弧数:"; 
	cin&gt;&gt;kd&gt;&gt;g.vexnum&gt;&gt;g.arcnum;
	//cout&lt;&lt;"请输入"&lt;&lt;g.vexnum&lt;&lt;"个顶点的值";
	for(i=0;i&lt;g.vexnum;i++){
		cin&gt;&gt;g.vexs[i];
	} 
	
	for(i=0;i&lt;g.vexnum;i++){
		for(j=0;j&lt;g.vexnum;j++){
			g.arcs[i][j].adj=infinity;
		}
	}
	//cout&lt;&lt;"请输入"&lt;&lt;g.arcnum&lt;&lt;"条弧的弧尾 弧头 权值：" &lt;&lt;endl;
	for(k=0;k&lt;g.arcnum;k++){
		cin&gt;&gt;v1&gt;&gt;v2&gt;&gt;w;
		i=locatevex(g,v1);
		j=locatevex(g,v2);
		g.arcs[i][j].adj=w;
	} 
	g.kind=kd;
	return ok;
}

status printdn(mgraph g){
	int i,j;
	printf("%d %d %d\n",g.kind,g.vexnum, g.arcnum);
	for(i=0;i&lt;g.vexnum;i++){
		printf("%c",g.vexs[i]);
	}
	printf("\n");
	for(i=0;i&lt;g.vexnum;i++){ 
		for(j=0;j&lt;g.vexnum;++j){//老师的j是j=i 
		if(g.arcs[i][j].adj&lt;infinity){
			printf("%d",g.arcs[i][j].adj);
		}
		else{
			printf("#");
		}
		}
		printf("\n");
	}
	return ok;
}

int tddn(mgraph g, vertextype v){
	int vi=0;
	int sum=0;
	vi=locatevex(g,v);
	for(int j=0;j&lt;g.vexnum;j++){
		if(g.arcs[vi][j].adj&lt;infinity){
			sum++;
		}
		if(g.arcs[j][vi].adj&lt;infinity){
			sum++;
		}
		
	}
	
	
	return sum;
}


int  main(){
	mgraph g;
	//printf("1-有向图，2-有向网，3-无向图，4-无向网\n");
	createdn(g);
	//printdn(g);
	cout&lt;&lt;"";
	for(int i=0;i&lt;=g.vexnum-1;i++){
		printf("The degree of vertex %c is:%d\n",g.vexs[i],tddn(g,g.vexs[i]));
	}
	
	return 0;
}					
					
					</pre>
				</div>
				
			</div>
		</div>
	</body>
</html>